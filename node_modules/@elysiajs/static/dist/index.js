"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf, __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: !0 });
}, __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: !0 }) : target,
  mod
)), __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: !0 }), mod);
var index_exports = {};
__export(index_exports, {
  default: () => index_default,
  staticPlugin: () => staticPlugin
});
module.exports = __toCommonJS(index_exports);
var import_elysia = require("elysia"), import_fast_decode_uri_component = __toESM(require("fast-decode-uri-component")), import_utils = require('./utils.js');
async function staticPlugin({
  assets = "public",
  prefix = "/public",
  staticLimit = 1024,
  alwaysStatic = process.env.NODE_ENV === "production",
  ignorePatterns = [".DS_Store", ".git", ".env"],
  headers: initialHeaders,
  maxAge = 86400,
  directive = "public",
  etag: useETag = !0,
  extension = !0,
  indexHTML = !0,
  decodeURI,
  silent
} = {}) {
  if (typeof process > "u" || typeof process.getBuiltinModule > "u")
    return silent || console.warn(
      "[@elysiajs/static] require process.getBuiltinModule. Static plugin is disabled"
    ), new import_elysia.Elysia();
  const builtinModule = (0, import_utils.getBuiltinModule)();
  if (!builtinModule) return new import_elysia.Elysia();
  const [fs, path] = builtinModule, normalizePath = path.sep !== "/" ? (p) => p.replace(/\\/g, "/") : (p) => p, fileCache = new import_utils.LRUCache();
  prefix === path.sep && (prefix = "");
  const assetsDir = path.resolve(assets), shouldIgnore = ignorePatterns.length ? (file) => ignorePatterns.find(
    (pattern) => typeof pattern == "string" ? pattern.includes(file) : pattern.test(file)
  ) : () => !1, app = new import_elysia.Elysia({
    name: "static",
    seed: prefix
  });
  if (alwaysStatic) {
    const files = await (0, import_utils.listFiles)(path.resolve(assets));
    if (files.length <= staticLimit)
      for (const absolutePath of files) {
        let handleCache2 = function({
          headers: requestHeaders
        }) {
          if (etag) {
            let cached = (0, import_utils.isCached)(
              requestHeaders,
              etag,
              absolutePath
            );
            if (cached === !0)
              return new Response(null, {
                status: 304,
                headers: (0, import_utils.isNotEmpty)(initialHeaders) ? initialHeaders : void 0
              });
            if (cached !== !1) {
              const cache2 = fileCache.get(pathName);
              return cache2 ? cache2.clone() : cached.then((cached2) => {
                if (cached2)
                  return new Response(null, {
                    status: 304,
                    headers: initialHeaders || void 0
                  });
                const response2 = new Response(file, {
                  headers: Object.assign(
                    {
                      "Cache-Control": maxAge ? `${directive}, max-age=${maxAge}` : directive
                    },
                    initialHeaders,
                    etag ? { Etag: etag } : {}
                  )
                });
                return fileCache.set(prefix, response2), response2.clone();
              });
            }
          }
          const cache = fileCache.get(pathName);
          if (cache) return cache.clone();
          const response = new Response(file, {
            headers: Object.assign(
              {
                "Cache-Control": maxAge ? `${directive}, max-age=${maxAge}` : directive
              },
              initialHeaders,
              etag ? { Etag: etag } : {}
            )
          });
          return fileCache.set(pathName, response), response.clone();
        };
        var handleCache = handleCache2;
        if (!absolutePath || shouldIgnore(absolutePath)) continue;
        let relativePath = absolutePath.replace(assetsDir, "");
        decodeURI && (relativePath = (0, import_fast_decode_uri_component.default)(relativePath) ?? relativePath);
        let pathName = normalizePath(path.join(prefix, relativePath));
        if (import_utils.isBun && absolutePath.endsWith(".html")) {
          const htmlBundle = await import(absolutePath);
          app.get(pathName, htmlBundle.default), indexHTML && pathName.endsWith("/index.html") && app.get(
            pathName.replace("/index.html", ""),
            htmlBundle.default
          );
          continue;
        }
        extension || (pathName = normalizePath(
          pathName.slice(0, pathName.lastIndexOf("."))
        ));
        const file = import_utils.isBun ? (0, import_utils.getFile)(absolutePath) : await (0, import_utils.getFile)(absolutePath);
        if (!file)
          return silent || console.warn(
            `[@elysiajs/static] Failed to load file: ${absolutePath}`
          ), new import_elysia.Elysia();
        const etag = await (0, import_utils.generateETag)(file);
        app.get(
          pathName,
          useETag ? handleCache2 : new Response(
            file,
            (0, import_utils.isNotEmpty)(initialHeaders) ? {
              headers: initialHeaders
            } : void 0
          )
        ), indexHTML && pathName.endsWith("/index.html") && app.get(
          pathName.replace("/index.html", ""),
          useETag ? handleCache2 : new Response(
            file,
            (0, import_utils.isNotEmpty)(initialHeaders) ? {
              headers: initialHeaders
            } : void 0
          )
        );
      }
    return app;
  }
  if (
    // @ts-ignore private property
    !(`GET_${prefix}/*` in app.routeTree)
  ) {
    if (import_utils.isBun) {
      const htmls = await (0, import_utils.listHTMLFiles)(path.resolve(assets));
      for (const absolutePath of htmls) {
        if (!absolutePath || shouldIgnore(absolutePath)) continue;
        let relativePath = absolutePath.replace(assetsDir, "");
        const pathName = normalizePath(path.join(prefix, relativePath)), htmlBundle = await import(absolutePath);
        app.get(pathName, htmlBundle.default), indexHTML && pathName.endsWith("/index.html") && app.get(
          pathName.replace("/index.html", ""),
          htmlBundle.default
        );
      }
    }
    app.onError(() => {
    }).get(
      `${prefix.endsWith("/") ? prefix.slice(0, -1) : prefix}/*`,
      async ({ params, headers: requestHeaders }) => {
        const pathName = normalizePath(
          path.join(
            assets,
            decodeURI ? (0, import_fast_decode_uri_component.default)(params["*"]) ?? params["*"] : params["*"]
          )
        );
        if (shouldIgnore(pathName)) throw new import_elysia.NotFoundError();
        const cache = fileCache.get(pathName);
        if (cache) return cache.clone();
        try {
          const fileStat = await fs.stat(pathName).catch(() => null);
          if (!fileStat) throw new import_elysia.NotFoundError();
          if (!indexHTML && fileStat.isDirectory())
            throw new import_elysia.NotFoundError();
          let file;
          if (!import_utils.isBun && indexHTML) {
            const htmlPath = path.join(pathName, "index.html"), cache2 = fileCache.get(htmlPath);
            if (cache2) return cache2.clone();
            await (0, import_utils.fileExists)(htmlPath) && (file = await (0, import_utils.getFile)(htmlPath));
          }
          if (!file && !fileStat.isDirectory() && await (0, import_utils.fileExists)(pathName))
            file = await (0, import_utils.getFile)(pathName);
          else throw new import_elysia.NotFoundError();
          if (!useETag)
            return new Response(
              file,
              (0, import_utils.isNotEmpty)(initialHeaders) ? { headers: initialHeaders } : void 0
            );
          const etag = await (0, import_utils.generateETag)(file);
          if (etag && await (0, import_utils.isCached)(requestHeaders, etag, pathName))
            return new Response(null, {
              status: 304
            });
          const response = new Response(file, {
            headers: Object.assign(
              {
                "Cache-Control": maxAge ? `${directive}, max-age=${maxAge}` : directive
              },
              initialHeaders,
              etag ? { Etag: etag } : {}
            )
          });
          return fileCache.set(pathName, response), response.clone();
        } catch (error) {
          throw error instanceof import_elysia.NotFoundError ? error : (silent || console.error("[@elysiajs/static]", error), new import_elysia.NotFoundError());
        }
      }
    );
  }
  return app;
}
var index_default = staticPlugin;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  staticPlugin
});
