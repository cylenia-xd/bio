"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: !0 });
}, __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: !0 }), mod);
var utils_exports = {};
__export(utils_exports, {
  LRUCache: () => LRUCache,
  fileExists: () => fileExists,
  generateETag: () => generateETag,
  getBuiltinModule: () => getBuiltinModule,
  getFile: () => getFile,
  isBun: () => isBun,
  isCached: () => isCached,
  isNotEmpty: () => isNotEmpty,
  listFiles: () => listFiles,
  listHTMLFiles: () => listHTMLFiles
});
module.exports = __toCommonJS(utils_exports);
let fs, path;
const isBun = typeof Bun < "u" && !!Bun.file;
function getBuiltinModule() {
  if (fs || (fs = process.getBuiltinModule("fs/promises")), path || (path = process.getBuiltinModule("path")), !path) {
    console.warn("@elysiajs/static require path to be available.");
    return;
  }
  return [fs, path];
}
async function listHTMLFiles(dir) {
  if (fs || getBuiltinModule(), isBun) {
    const glob = new Bun.Glob("**/*.html"), files = [];
    for await (const file of glob.scan(dir))
      files.push(path.join(dir, file));
    return files;
  }
  return [];
}
async function listFiles(dir) {
  if (fs || getBuiltinModule(), isBun) {
    const glob = new Bun.Glob("**/*"), files2 = [];
    for await (const file of glob.scan(dir))
      files2.push(path.join(dir, file));
    return files2;
  }
  const files = await fs.readdir(dir).catch(() => []);
  return (await Promise.all(
    files.map(async (name) => {
      const file = dir + path.sep + name, stats = await fs.stat(file).catch(() => null);
      return stats ? stats.isDirectory() ? await listFiles(file) : [path.resolve(dir, file)] : [];
    })
  )).flat();
}
function fileExists(path2) {
  return fs || getBuiltinModule(), fs.stat(path2).then(
    () => !0,
    () => !1
  );
}
class LRUCache {
  constructor(max = 250, ttl = 10800) {
    this.max = max;
    this.ttl = ttl;
    this.map = /* @__PURE__ */ new Map();
  }
  get(key) {
    const entry = this.map.get(key);
    if (entry)
      return entry[1] <= Date.now() ? void this.delete(key) : (this.map.delete(key), this.map.set(key, entry), entry[0]);
  }
  set(key, value) {
    if (this.interval || (this.interval = setInterval(() => {
      const now = Date.now();
      for (const [key2, entry] of this.map)
        entry[1] <= now && this.map.delete(key2);
    }, this.ttl)), this.map.has(key)) this.map.delete(key);
    else if (this.map.size >= this.max) {
      const oldestKey = this.map.keys().next().value;
      oldestKey !== void 0 && this.delete(oldestKey);
    }
    this.map.set(key, [value, Date.now() + this.ttl * 1e3]);
  }
  delete(key) {
    this.map.get(key) && this.map.delete(key);
  }
  clear() {
    this.map.clear();
  }
  size() {
    return this.map.size;
  }
  [Symbol.dispose]() {
    this.interval && clearInterval(this.interval);
  }
}
function isCached(headers, etag, filePath) {
  if (headers["cache-control"] && /no-cache|no-store/.test(headers["cache-control"]))
    return !1;
  if ("if-none-match" in headers) {
    const ifNoneMatch = headers["if-none-match"];
    return ifNoneMatch === "*" ? !0 : ifNoneMatch === null || typeof etag != "string" ? !1 : ifNoneMatch === etag;
  }
  if (headers["if-modified-since"]) {
    const ifModifiedSince = headers["if-modified-since"];
    try {
      return fs.stat(filePath).then((stat) => {
        if (stat.mtime !== void 0 && stat.mtime.getTime() <= Date.parse(ifModifiedSince))
          return !0;
      });
    } catch {
    }
  }
  return !1;
}
let Crypto;
function getFile(path2) {
  return isBun ? Bun.file(path2) : (fs || getBuiltinModule(), fs.readFile(path2));
}
async function generateETag(file) {
  return isBun ? new Bun.CryptoHasher("md5").update(await file.arrayBuffer()).digest("base64") : (Crypto || (Crypto = process.getBuiltinModule("crypto")), Crypto ? Crypto.createHash("md5").update(file).digest("base64") : void console.warn(
    "[@elysiajs/static] crypto is required to generate etag."
  ));
}
const isNotEmpty = (obj) => {
  if (!obj) return !1;
  for (const _ in obj) return !0;
  return !1;
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  LRUCache,
  fileExists,
  generateETag,
  getBuiltinModule,
  getFile,
  isBun,
  isCached,
  isNotEmpty,
  listFiles,
  listHTMLFiles
});
