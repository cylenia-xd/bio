import { Elysia, NotFoundError } from "elysia";
import fastDecodeURI from "fast-decode-uri-component";
import {
  LRUCache,
  fileExists,
  getBuiltinModule,
  listFiles,
  generateETag,
  isCached,
  getFile,
  isBun,
  listHTMLFiles,
  isNotEmpty
} from "./utils.mjs";
async function staticPlugin({
  assets = "public",
  prefix = "/public",
  staticLimit = 1024,
  alwaysStatic = process.env.NODE_ENV === "production",
  ignorePatterns = [".DS_Store", ".git", ".env"],
  headers: initialHeaders,
  maxAge = 86400,
  directive = "public",
  etag: useETag = !0,
  extension = !0,
  indexHTML = !0,
  decodeURI,
  silent
} = {}) {
  if (typeof process > "u" || typeof process.getBuiltinModule > "u")
    return silent || console.warn(
      "[@elysiajs/static] require process.getBuiltinModule. Static plugin is disabled"
    ), new Elysia();
  const builtinModule = getBuiltinModule();
  if (!builtinModule) return new Elysia();
  const [fs, path] = builtinModule, normalizePath = path.sep !== "/" ? (p) => p.replace(/\\/g, "/") : (p) => p, fileCache = new LRUCache();
  prefix === path.sep && (prefix = "");
  const assetsDir = path.resolve(assets), shouldIgnore = ignorePatterns.length ? (file) => ignorePatterns.find(
    (pattern) => typeof pattern == "string" ? pattern.includes(file) : pattern.test(file)
  ) : () => !1, app = new Elysia({
    name: "static",
    seed: prefix
  });
  if (alwaysStatic) {
    const files = await listFiles(path.resolve(assets));
    if (files.length <= staticLimit)
      for (const absolutePath of files) {
        let handleCache2 = function({
          headers: requestHeaders
        }) {
          if (etag) {
            let cached = isCached(
              requestHeaders,
              etag,
              absolutePath
            );
            if (cached === !0)
              return new Response(null, {
                status: 304,
                headers: isNotEmpty(initialHeaders) ? initialHeaders : void 0
              });
            if (cached !== !1) {
              const cache2 = fileCache.get(pathName);
              return cache2 ? cache2.clone() : cached.then((cached2) => {
                if (cached2)
                  return new Response(null, {
                    status: 304,
                    headers: initialHeaders || void 0
                  });
                const response2 = new Response(file, {
                  headers: Object.assign(
                    {
                      "Cache-Control": maxAge ? `${directive}, max-age=${maxAge}` : directive
                    },
                    initialHeaders,
                    etag ? { Etag: etag } : {}
                  )
                });
                return fileCache.set(prefix, response2), response2.clone();
              });
            }
          }
          const cache = fileCache.get(pathName);
          if (cache) return cache.clone();
          const response = new Response(file, {
            headers: Object.assign(
              {
                "Cache-Control": maxAge ? `${directive}, max-age=${maxAge}` : directive
              },
              initialHeaders,
              etag ? { Etag: etag } : {}
            )
          });
          return fileCache.set(pathName, response), response.clone();
        };
        var handleCache = handleCache2;
        if (!absolutePath || shouldIgnore(absolutePath)) continue;
        let relativePath = absolutePath.replace(assetsDir, "");
        decodeURI && (relativePath = fastDecodeURI(relativePath) ?? relativePath);
        let pathName = normalizePath(path.join(prefix, relativePath));
        if (isBun && absolutePath.endsWith(".html")) {
          const htmlBundle = await import(absolutePath);
          app.get(pathName, htmlBundle.default), indexHTML && pathName.endsWith("/index.html") && app.get(
            pathName.replace("/index.html", ""),
            htmlBundle.default
          );
          continue;
        }
        extension || (pathName = normalizePath(
          pathName.slice(0, pathName.lastIndexOf("."))
        ));
        const file = isBun ? getFile(absolutePath) : await getFile(absolutePath);
        if (!file)
          return silent || console.warn(
            `[@elysiajs/static] Failed to load file: ${absolutePath}`
          ), new Elysia();
        const etag = await generateETag(file);
        app.get(
          pathName,
          useETag ? handleCache2 : new Response(
            file,
            isNotEmpty(initialHeaders) ? {
              headers: initialHeaders
            } : void 0
          )
        ), indexHTML && pathName.endsWith("/index.html") && app.get(
          pathName.replace("/index.html", ""),
          useETag ? handleCache2 : new Response(
            file,
            isNotEmpty(initialHeaders) ? {
              headers: initialHeaders
            } : void 0
          )
        );
      }
    return app;
  }
  if (
    // @ts-ignore private property
    !(`GET_${prefix}/*` in app.routeTree)
  ) {
    if (isBun) {
      const htmls = await listHTMLFiles(path.resolve(assets));
      for (const absolutePath of htmls) {
        if (!absolutePath || shouldIgnore(absolutePath)) continue;
        let relativePath = absolutePath.replace(assetsDir, "");
        const pathName = normalizePath(path.join(prefix, relativePath)), htmlBundle = await import(absolutePath);
        app.get(pathName, htmlBundle.default), indexHTML && pathName.endsWith("/index.html") && app.get(
          pathName.replace("/index.html", ""),
          htmlBundle.default
        );
      }
    }
    app.onError(() => {
    }).get(
      `${prefix.endsWith("/") ? prefix.slice(0, -1) : prefix}/*`,
      async ({ params, headers: requestHeaders }) => {
        const pathName = normalizePath(
          path.join(
            assets,
            decodeURI ? fastDecodeURI(params["*"]) ?? params["*"] : params["*"]
          )
        );
        if (shouldIgnore(pathName)) throw new NotFoundError();
        const cache = fileCache.get(pathName);
        if (cache) return cache.clone();
        try {
          const fileStat = await fs.stat(pathName).catch(() => null);
          if (!fileStat) throw new NotFoundError();
          if (!indexHTML && fileStat.isDirectory())
            throw new NotFoundError();
          let file;
          if (!isBun && indexHTML) {
            const htmlPath = path.join(pathName, "index.html"), cache2 = fileCache.get(htmlPath);
            if (cache2) return cache2.clone();
            await fileExists(htmlPath) && (file = await getFile(htmlPath));
          }
          if (!file && !fileStat.isDirectory() && await fileExists(pathName))
            file = await getFile(pathName);
          else throw new NotFoundError();
          if (!useETag)
            return new Response(
              file,
              isNotEmpty(initialHeaders) ? { headers: initialHeaders } : void 0
            );
          const etag = await generateETag(file);
          if (etag && await isCached(requestHeaders, etag, pathName))
            return new Response(null, {
              status: 304
            });
          const response = new Response(file, {
            headers: Object.assign(
              {
                "Cache-Control": maxAge ? `${directive}, max-age=${maxAge}` : directive
              },
              initialHeaders,
              etag ? { Etag: etag } : {}
            )
          });
          return fileCache.set(pathName, response), response.clone();
        } catch (error) {
          throw error instanceof NotFoundError ? error : (silent || console.error("[@elysiajs/static]", error), new NotFoundError());
        }
      }
    );
  }
  return app;
}
var index_default = staticPlugin;
export {
  index_default as default,
  staticPlugin
};
